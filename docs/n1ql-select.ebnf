/****************
 *  N1QL SELECT *
 ****************/

/*
 *  select statement
 */
select ::= select-core order-by-clause? limit-clause? offset-clause?
select-core ::= select-from-core | from-select-core
select-from-core ::= select-clause from-clause? where-clause? group-by-clause?
from-select-core ::= from-clause where-clause? group-by-clause? select-clause

/*
 *  select clause
 */
select-clause ::= 'SELECT' ('ALL' | 'DISTINCT')? result-expr (',' result-expr)*
result-expr ::= (path '.')? '*' | expr ('AS'? alias)?
path ::= identifier ('[' (uint | '*') ']')? ('.' path)?
alias ::= identifier

/*
 *  from clause
 */
from-clause ::= 'FROM' from-term
from-term ::= from-path ('AS'? alias)? key-clause? | from-term join-clause | from-term unnest-clause | from-term nest-clause
from-path ::= (pool-name ':')? path
pool-name ::= identifier
key-clause ::= ('KEY' | 'KEYS') expr
join-clause ::= join-type? 'JOIN' from-path ('AS'? alias)? key-clause
join-type ::= 'INNER' | 'LEFT' 'OUTER'?
unnest-clause ::= join-type? 'UNNEST' path ('AS'? alias)?
nest-clause ::= join-type? 'NEST' from-path ('AS'? alias)? key-clause

/*
 *  where clause
 */
where-clause ::= 'WHERE' cond
cond ::= expr

/*
 *  group-by clause
 */
group-by-clause ::= 'GROUP' 'BY' expr (',' expr)* having-clause?
having-clause ::= 'HAVING' cond?

/*
 *  order-by clause
 */
order-by-clause ::= 'ORDER' 'BY' ordering-term (',' ordering-term)*
ordering-term ::= expr ('ASC' | 'DESC')?

/*
 *  limit clause
 */
limit-clause ::= 'LIMIT' uint

/*
 *  offset clause
 */
offset-clause ::= 'OFFSET' uint

/*
 *  expressions
 */
expr ::= literal-value | identifier | nested-expr | case-expr | logical-term | comparison-term | arithmetic-term | concatenation-term | function-call | subquery-expr | collection-expr | '(' expr ')'
logical-term ::= cond 'AND' cond | cond 'OR' cond | 'NOT' cond
case-expr ::= simple-case-expr | searched-case-expr
simple-case-expr ::= 'CASE' expr ('WHEN' expr 'THEN' expr)+ ('ELSE' expr)? 'END'
searched-case-expr ::= 'CASE' ('WHEN' cond 'THEN' expr)+ ('ELSE' expr)? 'END'
comparison-term ::= expr '=' expr | expr '==' expr | expr '!=' expr | expr '<>' expr | expr '>' expr | expr '>=' expr | expr '<' expr | expr '<=' expr | expr 'NOT'? 'BETWEEN' expr 'AND' expr | expr 'NOT'? 'LIKE' expr | expr 'IS' 'NOT'? 'NULL' | expr 'IS' 'NOT'? 'MISSING'
arithmetic-term ::= expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | expr '%' expr | '-' expr
concatenation-term ::= expr '||' expr
nested-expr ::= expr '.' expr | expr '[' expr (':' expr?)? ']'
subquery-expr ::= '(' select ')'

/*
 *  function calls
 */
function-call ::= function-name '(' ('DISTINCT'? ((path '.')? '*' | expr (',' expr)*))? ')'
function-name ::= identifier

/*
 *  collections
 */
collection-expr ::= exists-expr | in-expr | collection-cond | collection-xform
exists-expr ::= 'EXISTS' subquery-expr
in-expr ::= expr 'IN' expr
collection-cond ::= ('ANY' | 'SOME' | 'EVERY') variable (',' variable)* 'IN' expr (',' expr)* ('SATISFIES' cond)? 'END'
collection-xform ::= map-expr | reduce-expr | array-expr | first-expr
map-expr ::= 'MAP' variable (',' variable)* 'IN' expr (',' expr)* ('TO' expr)? ('WHEN' cond)? 'END'
reduce-expr ::= 'REDUCE' variable (',' variable)* 'IN' expr (',' expr)* 'TO' expr ('WHEN' cond)? 'END'
array-expr ::= 'ARRAY' expr 'FOR' variable (',' variable)* 'IN' expr (',' expr)* ('WHEN' cond)? 'END'
first-expr ::= 'FIRST' expr 'FOR' variable (',' variable)* 'IN' expr (',' expr)* ('WHEN' cond)? 'END'
variable ::= identifier

/*
 *  identifiers
 */
identifier ::= unescaped-identifier | escaped-identifier
unescaped-identifier ::= [a-zA-Z_$]  ( [0-9a-zA-Z_$] )*
escaped-identifier ::= '`' chars '`' ('i' | 's' | 'n')?

/*
 *  literal JSON (with nested expressions instead of values)
 */
literal-value ::= string | number | object | array | 'TRUE' | 'FALSE' | 'NULL'
object ::= '{' members? '}'
members ::= pair (',' members)?
pair ::= string ':' expr
array ::= '[' elements? ']'
elements ::= expr (',' elements)?

/**
 *  low level
 **/
string ::= '"' chars? '"'
chars ::= char chars?
char ::= unicode-character | '\' ('\' | '/' | 'b' | 'f' | 'n' | 'r' | 't' | 'u' hex-digit hex-digit hex-digit hex-digit )
number ::= '-'? uint frac? exp?
uint ::= digit | non-zero-digit digits
frac ::= '.' digits
exp ::= e digits
digits ::= digit digits?
non-zero-digit ::= [1-9]
digit ::= [0-9]
e ::= ('e' | 'E') ('-' | '+')?
hex-digit ::= [0-9a-fA-F]

/**
 *  comments
 **/
block-comment ::= '/*' ((text)? newline?)+ '*/'
line-comment ::= ('--' | '//') (text)? newline?
