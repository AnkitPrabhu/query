## Source code distribution :

###Note: 
*Any definition starting with a capital letter is public; the small case definitions can be seen only by that particular package. 
*Both shallow and deep copy of a non-array/object value is that value itself.
*A copy should give you a copy that you can use in another thread.

###Value

This subdirectory represents the data model. It is the in memory representation of the data from the disk. (Abstraction of the data that exists in JSON format).

####Value/value.go: 
The first constant declaration is _Tristate_.  It has three states, _TRUE_, _FALSE_ and _NONE_ (initialized to _iota_, which is used in constant declarations in Go. Its value starts at 0 in the const block and increments each time it is seen.  Refer to the Golang docs). 

The function _ToTristate_ takes as input a Boolean type and returns a Tristate type. If the function argument represents a True then it returns a True Tristate value, else it returns False. It is used to represent the metrics (which is defined as a type of value. Tristate in the struct of type BaseRequest) in server/http/http_request.go, which handles the http request step in the N1ql Architecture diagram and provides the metadata before the results. Conversely the ToBool function takes in a Tristate type and returns a Boolean.  

Value supports different data types that are supported by N1ql. They are Missing, Null, Binary, Boolean, Number, String, Array, Object and JSON.  Missing is specific to N1ql and Binary refers to unparsed JSON Bytes, represented by a bytes array.  It is a non-JSON value. The value Type JSON is all-encompassing and covers all N1ql values. 

The function String() is a Stringer interface, which is used in expression/stringer.go to visit nodes and convert from Type defined earlier to a string and return it. The _TYPE_NAMES variable is a slice of strings that contains the Type and its corresponding string representation. 

The _MARSHAL_ERROR constant represents an error string that is output when there is an unexpected marshal error on valid data. Marshal returns the JSON encoding of any input interface. It is used while implementing the method MarshalJSON.

The type ValueChannel is a channel of Value, where Value is an interface. (Channels in Go are pipes that connect concurrent goroutines) The results in a request for the server are of type ValueChannel. 

Values is a collection of Value. The type is defined as a slice of Value. Similarly CompositeValues is a slice of Values.  

Before we discuss the Value interface it is important to note the definition of the type Unsettable as a string.  This is used to report an error when an input type is incorrectly trying to set a nested property (valid in the case of an object) or index (valid in the case of an array) that does not exist for it, by invoking one of these methods defined in the Value interface.  The method receiver (a specially defined first argument for a function that is an instance of the type that it refers to, for eg. this Unsettable) is of type Unsettable and the method returns a string. If it is an empty string then it returns “Not Settable”, and if not then it specifies the field or index that is not settable which was an argument to the SetField or SetIndex method.

Type Value is an interface that is used for storing and manipulating a JSON value. It has a list of methods that are discussed below.  Each value will implement the methods that correspond to it, as discussed in the following sections. 

MarshalJSON:  This method is used by the json package. It is used to convert to JSON encoding. And returns a byte array of valid JSON values. 

Type: Returns the type of the input based on the earlier defined Types.

Actual: N1QL to native Go representation. It returns an interface.

Equals: Returns a Boolean based on if this and input argument Value are equal.

Collate: It returns –int, 0 or +int depending on if this sorts less than, equal to, or greater than the input argument Value to the method. It uses the type order defined previously.( This order has also been defined in the N1QL spec under order by.)

Truth: This method returns the Boolean interpretation of the input this for different values.

Copy: Returns a Value, which is a shallow copy of the input. 

CopyForUpdate: Returns a Value that is a deep copy of this. It is used during Updates. 

Field: It allows you to access a field or nested data in an object. Returns a value and a Boolean; the value being either a missing or the N1QL Value of the input for objects, and a true if found.  
This function returns a NULL_VALUE for all the value types except Object. 

SetField: This function is used to set a field in an object. For all other Value types the function Unsettable is called since this method is not valid for those types.
UnsetField: It deletes the input field. For all other Value types the function Unsettable is called.

Index: It allows you to access the entry at a particular index in the array. The return value is the Value at that index and a Boolean; the value being N1QL value of the input for the slice and a true if found.  

SetIndex: This function is used to populate the value at a particular index in the slice with val of type interface. Slices do not extend beyond their length. For any attempt to set an index that is greater than length, Unsettable is called.

Before we discuss the methods Slice and SliceTail it is important to be familiar with what a Slice is in Go.  Slices are similar to arrays in their underlying representation and have no specified length. It is a descriptor of an array segment and consists of a pointer to the array, the length of the slice, and the capacity of the slice (For e.g. we could allocate an array of 5 elements and create a slice from 2:4, the length of the slice in this case is 2 and the capacity is 3). It can be created with the built in make function where we can specify the length and capacity.  The syntax for defining a slice allows you to leave the start and/or end index blank. (For e.g. a[:], a[2:], a[:5]). For more detailed information please refer to the Golang documents chapter on arrays and slices.

Slice: This function takes in a start and end index and returns a value, which is the new slice from start to end, and a Boolean value that is true if the receiver value is of type array. For everything else it returns a NULL_VALUE and false. 

SliceTail: This function takes in a start index and returns a new slice value from the start until the end of the array. It also returns a Boolean value that is set as true if a slice was returned and false if not. For all non-array values the function returns a NULL_VALUE.

Descendants: Lists the descendants of an array or object in depth first order (multilevel list flattening) by adding it to an input buffer. 

Fields : Gives you the object fields by adding them to a string to interface map. This returns null for all types except object. ( it is used in expression/nav_field.go to navigate through fields of value Value).

In order to bring the data object into the value type system from a Go type, a function NewValue is defined. It takes as input a value of type interface and returns a Value.  If the input value is nil then we return a NULL_VALUE. If it is already a valid N1QL value then we return it as is.  For a float64, string and Bool type for val we cast it to the valid N1QL type and return it (we have defined a float64 to represent a float value at this time). For a slice of interfaces, we return a value of type sliceValue (which is defined below while discussing Value/array.go). For a map from string to interface it returns an objectValue. For a slice of Value, a slice of interfaces of length val is created, and on ranging over the values and we add them to it. Finally we cast it to a sliceValue and return it. In the event it’s a slice of AnnotatedValue (defined in Value/annotated.go) the procedure followed is the same as that for a slice of value. If the input type is a slice of bytes then we call the function NewValueFromBytes on the value (discussed below).  The default behavior is to range over the predefined _ Conversions, defined as a slice of reflect type with 3 predefined types (reflect.TypeOf returns the type of the input argument), string, Boolean and number. While looking though the types we check if the current val’s type can be converted to one of these predefined types. In the event it can be, we convert it and call newValue on the new interface, if not we return an error that says that a value for type t cannot be created.

In order to understand this better it is important to be familiar with the concept of reflection. It is a languages ability to inspect and dynamically call methods defined for that type at runtime and is primarily useful by statically typed languages (since if it was dynamically typed the compiler will allow the method to be called by any object failing at runtime if it doesn’t exist).  To read more implementation specific details about reflection in Go please refer to the golang laws of reflection. 

The function NewValueFromBytes is used to convert a slice of bytes into a Value. The input is a slice of byte and the output is of type Value. A variable parsedtype is created of type _ Type_.  We first validate the input bytes to check if it is valid json encoded data. This function is defined in the public repository dustin/gojson. It returns a nil if the json is valid. In the event that the err returned is nil, we try to identify the type of json value it is by calling locally defined function identifyType discussed later. If it is a Number, string, Boolean or null value we do the following. Create a variable of an empty interface and call Unmarshal to parse the json encoded data and store result into the variable.  If an error was returned by the Unmarshal function then we throw an error, since the data was not valid json encoding. If not we call NewValue on the parsed data and return that. In the case it is of another type (object or array) we create and initialize a new variable as a pointer to the structure parsedValue (defined in value/parsed.go as discussed later), and assign raw to the bytes. In the event an err was returned by the validate function, we set the parsedType variable in the struct to BINARY. If there was no error we set it to the type we identified before and return the pointer to the struct as a Value.

The function identifyType takes an input of bytes and returns its corresponding type. The function ranges over the bytes, and checks for the type of the byte. If it starts with a ‘{‘ it corresponds to an object, ‘[‘ corresponds to an array, ‘ ” ’ corresponds to a string, any digit and ’-‘, corresponds to a number, ‘t/f ’ is a Boolean type and ‘n’ is null.  If it is a whitespace then we continue the look to find the next byte. If none of these types fit then we throw an error stating that we were unable to identify they type of JSON data.

Value.go defines type copyFunc as a function that takes an input interface and returns an interface. It also defines a function self that takes is passed an interface that returns itself. It allows us to access the input object. It defines a function copyForUpdate that has input parameter val of type interface. It calls the CopyForUpdate for that particular value type and returns the interface returned by that call. This is used by array.go, when there is a necessity to copy all the elements of the array, which can have any JSON type.

###Value/missing.go:
Type missingValue is a type string. Variable MISSING_VALUE is defined and initialized to an empty string cast to missingValue.  The function NewMissingValue() returns a value, by returning MISSING_VALUE. The methods implemented for this value have a method receiver of type missingValue. The MarshalJSON implementation for this value, returns ‘_NULL_BYTES’, defined in value/null.go and nil since we should never marshal a missing value (if is not a valid json type). 

The Error() function returns a string describing which denotes which property or index was unidentified. In the event this information is not known, if it is empty, we return a general string that says “Missing field or index”.

Type missingValue implements all the methods defined by the Value interface.  For Type() it returns MISSING. For Equals() if the other Value is also a missing it returns true, else it returns false. This is as per the N1QL specs. Please refer to the table that compares Null and Missing values. The Collate() function returns an integer representing the position of Missing with respect to the other values type by subtracting them and casting the result to an integer.  As per the N1ql specs the truth-value of a missing evaluates to a false, and hence the Truth method returns a false.  Both Copy and CopyForUpdate methods return the missingValue itself. *Refer to Note 2. The methods SetField, UnsetField and SetIndex return Unsettable and false (SetIndex doesn’t return a boolean) since these methods are not valid for missing values.   The method Index and Field call function missingField and missingIndex which in turn casts the input field and index (cast to a string) to a missing value respectively. Both methods Slice and SliceTail return MISSING_VALUE as defined previously along with a false, Descendants returns the input buffer itself and Fields returns a nil.

###Value/null.go:
nullValue type is an empty struct. The variable NULL_VALUE is initialized as a pointer to an empty nullValue.  The variable _NULL_BYTES is a slice of byte representing null string. The NewNullValue function returns a value NULL_VALUE.

The implemented methods for null are similar to those for missing. The marked differences are for Index and Field methods returning NULL_VALUE and false similar to Slice and SliceTail. Equals and Collate are also similar but consider the null value type instead of missing. 

For Boolean, number and string values the methods Copy, CopyForUpdate, Field, SetField, UnsetField, Index, SetIndex, Slice, SliceValue, Descendants and Fields() are as discussed before. 

###Value/Boolean.go:
boolValue is defined as a bool type. There are four predefined variables, FALSE_VALUE/ TRUE_VALUE that are assigned a false and true value (NewValue() is called to ensure that it is a value), and _FALSE _BYTES / _TRUE _BYTES that are slices of bytes representing false and true.  Type() returns a Boolean. Methods Actual and Truth cast the input boolValue to a bool and return it.  In order to check if the method receiver boolValue is equal to the input argument Value, we check its type. If it is a bool value we return a true if they are both the same type else a false. If it is a *parsedValue we call the equals method again by parsing the input Value (call parse() defined in parsed.go), and if it is an *annotatedvalue we call the Equals method again with the Values’ Value. By default a false is returned. 

Collate is similar in nature for types parsedValue and annotatedValue. The default behavior is to return BOOLEANs position wrt other types. For the case that both values being compared are Boolean, if they evaluate to the same value (true or false) a 0 is returned. If not, if the method receiver is a false then -1 is returned and otherwise 1 is returned. 

###Value/number.go:
floatValue is defined as type float64. The variables ZERO_VALUE and ONE_VALUE are initialized to 0.0 and 1.0 respectively. MarshalJSON casts the method receiver to float64, and uses the math package functions to check if its NaN, +infinity or –infinity, in which case it returns a slice of byte representing that value, else it calls jsons marshal function on the cast value. The Type method returns Number value. The Actual method returns the method receiver cast as a float64. The Truth method returns true in the event the receiver is not 0 and it isn’t a NaN value. For all other cases it returns false. Equals and Collate are similar to the method definitions for previous values. If the second compared value is not equal to the receiver, equals returns face and collate returns (this-other). 

###Value/string.go:
stringValue is defined as type string. Variable EMPTY_STRING_VALUE is defined as an empty string.  All the methods defined for the string value are similar to previous definitions. The major difference is for the method Collate, when the type of input argument is stringValue. Here we compare the 2 strings and return -1 if the receiver is less than the input.

###Value/array.go
sliceValue is defined as a slice of interfaces. The variable EMPTY_ARRAY_VALUE is initialized as a slice of interface. MarshalJSON calls the local function marshalArray on the receiver. The function marshalArray has input as a slice and output as a slice of bytes and an error. If the slice is nil then we return NULLBYTES as defined earlier in null.go. We create a new buffer, and write a ‘[‘ to the buffer. We range over the slice, if I is greater than 0, we write a ‘,’ to the buffer since it means that an entry has been made. If not we create a value out of e, Marshal it and then write it to the buffer if there is no error from the marshal. Once we have completed looping over the slice, we write a ‘]’ and return the buffer. The Type method returns type Array. The actual method returns the receiver itself by casting it to a slice of interfaces.  

The Equals and collate method are similar. For types *scopevalue, *annotatedvalue and parsedvalue they call Equals/Collate again on the value of the second.  For type slicevalue we call arrayEquals that does an element by element comparison to return true if all elements are the same and false if not. If the length of the 2 arrays is not the same they are not equal and false is returned. If it is equal then we range over the first array and call equals to check if the elements of the second array are equal to the each item in the first. If not we return false, else we return true. 

For type listvalue (discussed below), the call to arrayCollate is made with a slice of the second value.  In the event that the slice has one or more elements, Truth returns true, else false.  For arrayCollate we range over the first array. If the index is greater than the length of the second array then we return 1 since the first array is greater. If not we call collate for the elements of both arrays (once being the receiver and the other an input parameter). If it returns anything except 0 then we return that number.(the reason we cant return 0 here is that we need to compare all the elements of the arrays before we say they are equal) if we have ranged over all the elements of array1 then we subtract the lengths and return. Here it is important to note that the value returned in this case is either 0 or a negative int, since array1 might be a subset of array2. 

The Copy method for arrays, calls copySlice with inputs this (the receiver) and self and the CopyForUpdate with copyForUpdate as defined in value.go. This allows for a copy for every element of the array by calling its CopyForUpdate function. The copySlice function takes as input a slice of interfaces, the source and a copyFunc copier (as described before) and returns a slice of interface. If the source is nil then we return nil. If not we create a result slice (of interface), range over the source and add it into the result by casting it to the copier. Once this is done we return the result.  

Methods that deal with the Field are not valid for arrays and hence return Unsettable. Field returns a NULL_VALUE and Fields() returns a nil.  For the Index method, if the input index is negative then we count the index from the last element. If it is positive and less than the length we return the element at that index and true saying a value was returned and if not we return a missing value and false.

For the SetIndex method, we do a similar check. In the event the new adjusted index is less than 0 or greater than/equal to the length of the slice we return Unsettable. If it is a valid index, we check the type of value. If it is a missing value then we set it to nil (since we do not wish to add this field) and if anything else we add the value at the particular index.  If up until this point we haven’t returned anything, for all other cases we return a nil. 

The Slice and SliceTail methods have similar checks with the Slice method having an additional check for the end. If any defined index (start of end) is –ve then we add it to the end to get the actual adjusted index (as per the N1QL specs).  For Slice, if it is a valid slice (start<=end, start >=0 and end less than the length) we return the slice by creating a valid value and also return true. For SliceTail if start is valid (>= 0) then we return a slice from start till the length of the slice and a bool value true. If the indices are not valid we return a missing value and false.

The Descendants method has input parameter buffer, which is a slice of interfaces. It returns this slice after flattening out the elements of the array and appending it into the buffer. This is done in child first (depth first) order.  In the event the buffer is full (capacity < length of the buffer + the current element), then we grow the buffer by twice of length of the buffer + this element + 1.  Once we have the required space in the buffer, then we range over the slice and append the children to the buffer, and call Descendants recursively until there are no elements left. Finally we return the buffer. 

Since sliceValue defined slices do not extend beyond the set length, we create a new type listValue that is a struct containing slice values. This enables us to call all the implemented methods for slicevalue without having to redefine them.  The difference is in Copy and SetIndex methods. Copy returns a pointer to listValue whose entry is the return value of the call to slicevalues copy method. The SetIndex method, initially Checks to see if there is a necessity to grow the slice. If the index is greater than the length of the receiver slice, we check capacity next. In the event the index is smaller than the capacity, we assign the current slice to the new slice from 0 to index+1. If we have overrun the capacity as well, then we need to grow the slice. Hence we make a slice with length index+1 and capacity twice as much, and reset the receiver. Finally we call the SetIndex method for the sliceValue. 


###Value/object.go :
objectValue is a type of map from string to interface. Variable EMPTY_OBJECT_VALUE is initialized as a map from string to interface. The method MarshalJSON checks to see if the receiver of type objectValue is nil and if so returns _NULL _BYTES. If not it creates a new buffer and writes a ’{‘ to it. We call function sortedNames on the receiver to sort the fields. It uses the Sort package to sort the keys in the object.  We range over all the keys, for each value associated with the keys, if its type is missing do not populate the field. If not and the iterator is greater than 0 we add a ‘,’ to the buffer (since that means we have populated 1 field in the buffer). We write out a ‘ ” ’, then the key, a ‘ : ‘, and then the value. Before the value is written out to the buffer, we Marshal it and check for errors. Finally once all the fields of the object have been marshaled  ‘}’  is written to the buffer and the bytes are returned by calling Bytes(). (Returning to the []byte can me done anytime by calling Bytes() ). This is in keeping with the JSON format to define objects.

The function sortedNames takes an input a map and returns a string that represents a sorted set of keys. We range over the object and append all keys to a variable that is defines as a slice of strings. The type StriingSlice is defined by the sort package and its sort method sorts in increasing order of input. We sort this slice of string and return it back to the caller (namely MarshalJSON).  

The Type method returns type OBJECT. The actual method returns the receiver itself by casting it to a map of string to interfaces.  The Equals and collate method are similar. For types *scopevalue, *annotatedvalue and parsedvalue they call Equals/Collate again on the value of the second. (for parsed value we first parse the input and then call equals with that ray bytes slice)  For type objectvalue, in Equals, we call objectEquals that does an element by element comparison to return true if all fields are the same and false if not. The first comparison made by the function is the length of the two objects, if not the same it returns false. We range over the first object. If the value of the second is not equal to the value of the first (note that they are already in sorted order)  or if that field is missing then we return false. If not er return true which means that all the fields match and the two objects are equal. 

For the type objectvalue in Collate we call objectCollate to determine object ordering.  The function takes two objects (both maps) and returns an int. The first step is to see if one object is larger than the other and if not directly return that difference. Now that we know the lengths are equal, we do a name-by-name comparison.  The first step is to collect all the keys (field names) in the object and initialize their values to false. The names are collected in allnames and the corresponding values are stored in allmap. We range over all the fields and compare the values associated with them by calling collate (if there was no corresponding value in the objects map under a field then we return 1 if the field was missing in object 1 and -1 if it was missing in field2. This is as per the N1QL specs).  If Collate returns a non-zero value that is returned. If it is zero then we still need to compare the rest of the fields. Finally since all the names and values are equal we return 0.

The truth method returns true if there are one or more fields in the object. The Copy method for objects, calls copyMap with inputs this (the receiver) and self and the CopyForUpdate with copyForUpdate as defined in value.go. This allows for a copy for every field of the object by calling its CopyForUpdate function. The copyMap function is similar to the copySlice function with the major difference being that it operates on maps as opposed to slices.
 
For the Field method, the method receiver is of type objectValue, which is defined as a map from a string to an interface.  It initializes result to the field in this (it is a map and hence access that value). If ok then we return the result by converting it into the Value type system and return true for the bool. If the field does not exist in the object then it returns a missing and a false to indicate that the field was not found. It does this by calling missingField on the field. The function is defined in value/missing.go and is as defined earlier in this document. 

The SetField method returns an error that depicts if the field was successfully set. The method receiver is of type objectValue and the function returns an error stating if the field of type string was successfully set and mapped to the val of type interface. The code checks to see the type of value, if it is a missingValue it deletes the field, but the default behavior is to set the value for the field in the map that defines objectValue.  The reason that delete is called as opposed to calling the function UnsetField is in the future, for this function, we might decide to throw an error in the event that the field was missing. Since the field has been successfully set it returns a nil error.  

The UnsetField method takes the field string as an input and gives you an error. It takes as input the field to delete, and deletes it from the object. It returns nil to indicate that the specified field has been deleted successfully. 

The Index, Slice and SliceTail methods return a NULL_VALUE, and the SetIndex method returns an error by calling Unsettable. The Fields method returns the receiver itself. Similar to the Descendants method implementation is similar to the one for the arrays. The buffer is grown similarly. The main difference is that we sort over all the fields and then append the values into the buffer, which is a slice of interfaces, and return that. 


###Value/annotated.go:
The annotatedValue is used to handle any extra information about the value. Type AnnotatedChannel is a channel of AnnotatedValue. Type AnnotatedValues is a slice of AnnotatedValue. We define type AnnotatedValue as an interface that inherits from Value (it extends value). It also has additional methods that are described below. 

Function NewAnnotatedValue takes in an interface and returns an AnnotatedValue. This function is used to create an Annotated Value used to hold attachments. If the type of the value interface is AnnotatedValue, then we return the value itself. If the type is Value, we set the Value to the value variable for struct annotatedValue and attacher as a nil. A pointer to the structure is returned. For the default behavior, we have it call itself again by creating a value from the input interface and passing it into the function.

annotatedValue is defined as a structure with Value and an attacher. An attacher is  a struct having variable attachments of type map. The MarshalJSON function calls json.Marshal to encode the input value. For the GetValue() method, input receiver is of type annotatedValue, and we return the value component of this value. The Copy and CopyForUpdate methods return a pointer to the structure annotatedValue with Value field being the return value of the Copy / CopyForUpdate cal for the value element. For the second variable defined in the struct, namely attacher we call the copyMap function with the attachments and self (similar to the previous defined use). For CopyForUpdate, the attachments field is populated by the receivers’ attachments. 

The SetAttachments method takes as input the attachments and populates the receivers attachment field. For GetAttachment, we check if the attachment is nil, if not we return the value of the attachment for the given key string. The method SetAttachment attaches an object to the value with the specified key. Any existing value will be overwritten with the new value. The method RemoveAttachment method takes in a key string and returns an interface that has the object attached to the given key removed and the value is returned.

###Value/scope.go:
ScopeValue provides alias scoping for subqueries, for’s, lets etc.  ScopeValue is a type struct that inherits Value and has a parent Value. The function NewScopeValue takes as input a value interface, and a parent and returns a pointer to a scopevalue struct. An example of a possible usage is when we use the same alias for subqueries, and we need to maintain the block hierarchy (inner block / outer block ). The MarshalJSON method is similar to previous implementation. The Copy and Copy for update functions use the functions for receivers value and populate it. The parent is assigned to the parent field in the receiver. The method Field implements scoping., checks for the field of the value in the receiver struct, into result, and if valid returns the result.  If the parent is not nil and there was an Field function called previously returns a false, we call Field on the parent and return that. Else a missingField is returned. It searches itself and then the parent for the input parameter field. 

The Fields method returns the fields in the scopevalue. If the parent in scopeValue is nil then we return the fields in the value. If not we need to create a map that contains both the parents’ fields and the values fields and return that map. 

###Value/sort.go:
The type Sorter is a structure containing one element of type Value. It sorts an array value in place.  The NewSorter function returns a pointer to a struct, with the value field. The function Len, calculates the length. It initially converts the value into a valid Go type, and checks its type. If it is a slice of interfaces then we return the length of the Go type, if not we return 0.  The method Less checks to see if the first element in the slice of interfaces is less than the second. This is done, by calling Collate on the values. For any other type we return false. The function Swap, swaps the elements in index i and j. 

###Value/parsed.go:
The type parsedValue is a structure that contains three elements. The first is raw which is a slice of bytes, the second is parsedType which is of type _Type_, and finally we have parsed which is a _Value_. The method MarshalJSON checks for the receivers parsedType. If it is an object or an array, we call its method MarshalJSON. If it is binary then we return the raw bytes and an error saying that Marshaling a binary value returns raw bytes. The default is to return the raw bytes and nil as the error. The Type method returns the parsedType of the receiver. The Actual method checks to see if the parsedType is binary. If it is then we return the raw bytes. Otherwise we call the Actual method for the values in the receiver.

The method Equals first checks to see of the parsedType is binary. If it is we marshal the second value and then call Equal to check if the bytes are equal. If not we parse it first and then call Equals again. The parsedValue has _raw_ bytes and we will eventually parse it. It implements delayed parsing. Similarly for collate if the parsedType for the receiver is binary, and the other value type is also binary then we call MarshalJSON on the other value and do a bytes compare. If the other is not of type binary then we return the relative position of that type with respect to binary. Finally if the receiver type was not binary we parse it, and then call collate again. 

The truth method returns true if the recievers parsedType is Binary. If not then we parse the input bytes and then call Truth on it. The copy method checks to see if the parsedtype is not binary and it isnt an array or object then we parse the bytes and call that values respective Copy method. If it is binary then we set the raw variable for a struct to the receivers raw value and the parsedType to the receivers parsedType and return a pointer to this struct. For CopyForUpdate, if the receivers parsedType is Binary, then we call the Copy function and return. If not we parse the bytes and then call CopyForUpdate over that. The parse function is discussed below.

The field method, takes in a field string. The first step is to check if the parsed Value is nil. If it isnt we call the Field method for that value and return it. In the event that it is nil, we first make a check to see if the parsedType is an object. If not then we return missingField and false.(Since only objects have fields). We use the jsonpointer package which is the public go-jsonpointer implementation package on github. It defines a string syntax for indentifying a specific value in a JSON document. We use the Find method here that tries to find a section of raw JSON, and takes as input arguments the slice of bytes and a path string. It returns a slice of bytes. If the error it returns is not nil or if the result of the Find is nil and the error is nil, then we return a missingField. If the result is not nil then we call NewValueFromBytes on the result to get a valid value and return true. 

The SetField (and UnsetField)  method returns Unsettable if the parsedType is not object and if it is then it parses the receiver and calls the corresponding SetField (or UnsetField) method. Similarly the SetIndex,Slice and SliceTail methods check if the type is array and call the corresponding method over the parsed bytes. The Index method, calls the index method for the type of value parsed, if it is not nil. If it isnt of type array then we return missingIndex. Otherwise we need to go through the raw bytes and find this index, similar to the Field method, and call NewValueFromBytes to get a value to return. If this.raw is nil or if we didnt find the index, we return missingIndex. The Descendants and Fields methods both check to see if the parsedType for the receiver parsedValue is Binary. If it is, Descendants returns the buffer and Fields returns nil. If not calls parse and then calls the methods on that new value. 

The parse method is used to populate the value in the structure. If the value is nil, and the parsedType is binary then we panic since we are trying to parse a non JSON value. If not then we create a variable of type interface and Unmarshal the raw bytes, and add it to p. If an error is return by the Unmarshal then we panic and return an unexpected parse error. If not we populated the value field parsed with the NewVaue of the interface. The value is finally returned.
   
###Value/set.go:
Set implements a hash set of values. It is a type defined as a struct containing the following elements. _nills_ which is a bool type, missings and nulls which are Value's, booleans, numbers, strings, arrays and object which are maps from bool,float64,and string to Value respectively and finally blobs which is a slive of Value. The function NewSet takes as input an integer and returns a pointer to the Set structure. The integer decines the capacity of the object fields. The Add method, adds a Value _item_ to the receiver by calling Put. The method Put has input parameters key and item, both of type Value. If the key is nil then the nills attribute is set to true for the struct and we return from the function. We check for the keys type. If it is an object then we call MarshalJSON and set the object value in the struct to this item. Similarly for array. If the type is null then we set the missings attribute for the receiver to item. Similarly for null.If the type is Boolean, number or string we call actual for the key to convert it into native golag and then cast it to bool,float64 or string before setting the value for that key to item. For the type binary, we append the item to the blobs. The default case throws an error since the value type is unsupported. Similar to how Put processes the different types, Has sets a variable ok to depict true if that particular field is set. We finally return that boolean value. Similarly remove, deletes the entry from the corresponding type for the maps. For missing and null it sets the attributes to nil and for object and array deletes that entry. The method Len returns the length of the set by adding the length of each element (for missings and nulls it increments by one only if they arent nil, and if nills are true then it increments by one). The length is then returned. 

The Values() method, returns a slice of Value that contains all the values in the Set. It creates a variable that is a slice of Values and appends all the existing elements in the set to it. The Actuals method is similar to the Values method except that before appending the values to the slice of interface, we convert it into a golang type by calling actual and then return the slice.







